# Compressing-files-with-Huffman-Coding

Huffman编码：根据词频构建Huffman树，实现对文本的前缀编码。

1、统计文本中每个字符出现的次数，放入优先队列中，构建一棵空的二叉树；

2、取出频率最小的两个字符a、b，字符a、b的频率分别作为此二叉树的左右结点，左结点的编号为1，右结点的编号为0，其频率之和（fa + fb）作为该二叉树的父亲节点，放入优先队列，并将fa  、fb 从优先队列中除去；

3、重复第二步操作，直至优先队列中只剩下一个数，即为此Huffman树的根节点。

4、从根节点到每个叶节点（文本中出现的字符）的“路径”，即0、1序列串就是该字符的前缀编码。

注：这种编码方式保证了，任意一个字符的编码都不会是其他字符编码的前缀，这样在解码过程中就不会混淆。



数据结构：

为方便记录每个字符的前缀编码，在构建Huffman树过程中，需要保存每一个结点的父亲节点、左右儿子结点、叶节点对应字符、当前结点频率。



压缩过程：

1、首先构建Huffman树，获得每个字符对应的前缀编码；

2、将字符及其对应的前缀编码等压缩信息写入压缩文档中，便于解码；

3、扫描文本，将文本中的字符转换成0、1串，每八位，即一个字节对应的字符存储到压缩文件中。

注：如果最后存储的0、1串不足八位，则在末尾补0，然后将补的位数信息写入压缩文件中。



解压过程：

1、读取压缩信息；

2、扫描压缩文本，将每个字符转化成0、1串，匹配字符的前缀编码，转化成原始文件。

注：解码时需删除之前补充的位数



一点体会：

1、总在循环内，动态申请数组，会导致程序崩溃；

2、千万不要在循环内，每次都调用strlen函数，我表示没能深入了解此函数内涵，导致程序慢的要死；

3、原文本越大，压缩率越高，对于一个2M的文件，压缩率大约在45%左右。